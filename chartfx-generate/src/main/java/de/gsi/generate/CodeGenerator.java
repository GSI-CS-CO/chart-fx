package de.gsi.generate;

import static java.nio.file.StandardOpenOption.*;

import java.io.IOException;
import java.io.Writer;
import java.nio.file.*;
import java.util.*;
import java.util.function.UnaryOperator;
import java.util.stream.Collectors;

import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;

/**
 * Proof of concept code generator that gets called by the maven exec plugin during the generate
 * sources phase. It checks the source files for code gen templates by assuming some naming convention,
 * and then does search/replace based on sections within the source file. This allows multiple
 * output types to be generated into a single class.
 *
 * Currently the generated class inherits from the base class, but I'm not sure that's necessary.
 * We could just generate a full copy of the base class and then add sections within the template
 * area. TBD.
 *
 * @author ennerf
 * @author Alexander Krimm
 */
@Mojo(name = "generate-sources", defaultPhase = LifecyclePhase.GENERATE_SOURCES)
public class CodeGenerator extends AbstractMojo {
    public static final String JAVA_FILE_SUFFIX = ".java";
    public static final String START_TEMPLATE = "//// codegen:";
    public static final String END_TEMPLATE = "//// end codegen";
    public static final String COMMAND_SKIP = "skip";
    public static final String COMMAND_CAST_RETURN = "returncast";
    public static final String COMMAND_SUBST = "subst";
    public static final String PROTO_UTILCLASS_SUFFIX = "GenBase";
    public static final String PROTOTYPE_CLASS_SUFFIX = "DoubleProto";
    public static final String AUTOGENERATED_WARNING_HEADER = "// This file has been generated automatically by chartfx-generate. Do not modify!\n";
    // TODO: remove these and read from file comment instead:
    public static final String PROTOTYPE_TYPE = "double";
    private static final String LINE_COMMAND = "//// codegen:";
    final String[] outputTypes = { "float", "char", "short", "int", "long", "boolean", "byte" };

    @Parameter(defaultValue = "${project}", required = true, readonly = true)
    MavenProject project;

    @Parameter(defaultValue = "${project.build.sourceDirectory}", readonly = true)
    String input;
    @Parameter(defaultValue = "${project.build.directory}/generated-sources/codegen", readonly = true)
    String output;

    @Override
    public void execute() throws MojoExecutionException {
        final Path inputPath = Path.of(this.input);
        final Path outputPath = Path.of(this.output);

        // Add the generated classes to the build path
        project.addCompileSourceRoot(this.output);
        if (getLog().isInfoEnabled()) {
            getLog().info("Added directory for generated sources to compile sources: " + outputPath);
        }

        // Adding other types to helper function classes (...GenBase.java)
        extendUtilityClass(inputPath, outputPath);

        // Adding new classes for different types (...DoubleProto.");java)
        addDataTypeVariants(inputPath, outputPath);
    }

    private void addDataTypeVariants(final Path inputPath, final Path outputPath) throws MojoExecutionException {
        final List<Path> sourcesTypes = getSourceFiles(inputPath, PROTOTYPE_CLASS_SUFFIX);

        for (final Path source : sourcesTypes) {
            // Create output package
            Path relativePath = inputPath.relativize(source);
            Path outputDirectory = getOutputDirectory(outputPath, relativePath);

            // Find base class to be generated
            final String sourceClassName = removeTail(source.getFileName().toString(), JAVA_FILE_SUFFIX);
            getLog().info("Generating primitive types for class " + sourceClassName);
            final String outputClassNameBase = removeTail(sourceClassName, PROTOTYPE_CLASS_SUFFIX);
            final List<String> sourceContent = getFileContents(source);

            // Generate output file
            // primitive types
            for (final String outputType : outputTypes) {
                final String outputClassSuffix = outputType.substring(0, 1).toUpperCase() + outputType.substring(1);
                final String outputClassName = outputClassNameBase + outputClassSuffix;
                final Path dest = outputDirectory.resolve(outputClassName + JAVA_FILE_SUFFIX);
                try (Writer writer = Files.newBufferedWriter(dest, CREATE, WRITE, TRUNCATE_EXISTING)) {
                    // Write minimum class layout. Maybe use JavaPoet?
                    writer.write(AUTOGENERATED_WARNING_HEADER);
                    writer.write("// autogenerated code for " + outputType + " - " + outputType + " from double\n");
                    writeLines(sourceContent, writer, line -> {
                        // add a "// noconvert" comment to a line to suppress replacing double by the current type
                        if (line.contains("// noconvert")) {
                            return line;
                        }
                        return line.replace(PROTOTYPE_TYPE, outputType).replace(PROTOTYPE_CLASS_SUFFIX, outputClassSuffix);
                    });
                } catch (IOException e) {
                    throw new MojoExecutionException("Error writing file", e);
                }
            }
            // generic type
            final String outputClassSuffix = "Object";
            final String outputClassName = outputClassNameBase + outputClassSuffix;
            final Path dest = outputDirectory.resolve(outputClassName + JAVA_FILE_SUFFIX);
            try (Writer writer = Files.newBufferedWriter(dest, CREATE, WRITE, TRUNCATE_EXISTING)) {
                // Write minimum class layout. Maybe use JavaPoet?
                writer.write(AUTOGENERATED_WARNING_HEADER);
                writer.write("// autogenerated code for Object<T> from double\n");
                writeLines(sourceContent, writer, line -> {
                    // add a "// noconvert" comment to a line to suppress replacing double by the current type
                    if (line.contains("// noconvert")) {
                        return line;
                    }
                    String result = line.replace(PROTOTYPE_CLASS_SUFFIX, line.contains("class") ? "Object<T>" : "Object")
                                            .replace(PROTOTYPE_TYPE, "T");
                    if (line.contains("allocate(")) {
                        result = result.replace(") {", ", final Class<T[]> clazz) {");
                    }
                    if (result.contains("new T")) {
                        result = "try { " + result.replaceAll("new T\\[(.*)]", "clazz.getConstructor(int.class).newInstance($1)")
                                 + " } catch (InstantiationException | NoSuchMethodException | IllegalAccessException | java.lang.reflect.InvocationTargetException e) { throw new IllegalArgumentException(\"Could not allocate array for given type\", e);}";
                    }
                    if (line.contains("static ") && !line.contains("static class")) { // add type parameter to static methods
                        return result.replace("static", "static <T>");
                    }
                    return result;
                });
            } catch (IOException e) {
                throw new MojoExecutionException("Error writing File", e);
            }
        }
    }

    private void extendUtilityClass(final Path inputPath, final Path outputPath) throws MojoExecutionException {
        for (final Path source : getSourceFiles(inputPath, PROTO_UTILCLASS_SUFFIX)) { // loop over all prototoype classes
            // Create output package
            final Path relativePath = inputPath.relativize(source);
            final String packageName = relativePath.getParent().toString().replaceAll("(\\\\|/)", ".");
            Path outputDirectory = getOutputDirectory(outputPath, relativePath);

            // Find name to be generated
            String sourceClassName = removeTail(source.getFileName().toString(), JAVA_FILE_SUFFIX);
            String outputClassName = removeTail(sourceClassName, PROTO_UTILCLASS_SUFFIX);

            // log output
            if (getLog().isInfoEnabled()) {
                getLog().info("Generating primitive methods for helper class " + packageName + "." + sourceClassName);
            }

            // Generate output file
            Path outputFile = outputDirectory.resolve(outputClassName + JAVA_FILE_SUFFIX);
            final List<String> sourceContent = getFileContents(source);
            try (Writer writer = Files.newBufferedWriter(outputFile, CREATE, WRITE, TRUNCATE_EXISTING)) {
                // Write minimum class layout. Maybe use JavaPoet?
                writer.write(AUTOGENERATED_WARNING_HEADER);
                generateContent(sourceContent, writer, outputClassName);
            } catch (IOException e) {
                throw new MojoExecutionException("Error reading File", e);
            }
        }
    }

    private List<String> getFileContents(final Path source) throws MojoExecutionException {
        final List<String> sourceContent;
        try {
            sourceContent = Files.readAllLines(source);
        } catch (IOException e) {
            throw new MojoExecutionException("Error reading File", e);
        }
        return sourceContent;
    }

    private Path getOutputDirectory(final Path outputPath, final Path relativePath) throws MojoExecutionException {
        Path outputDirectory = outputPath.resolve(relativePath.getParent());
        try {
            Files.createDirectories(outputDirectory);
        } catch (IOException e) {
            throw new MojoExecutionException("could not create directories", e);
        }
        return outputDirectory;
    }

    private List<Path> getSourceFiles(final Path inputPath, final String protoUtilclassSuffix) throws MojoExecutionException {
        final PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:**" + protoUtilclassSuffix + JAVA_FILE_SUFFIX);
        final List<Path> sources;
        try {
            sources = Files.walk(inputPath).filter(matcher::matches).collect(Collectors.toList());
        } catch (IOException e) {
            throw new MojoExecutionException("Could not enumerate files", e);
        }
        return sources;
    }

    /**
     * Generate some sort of code, e.g., search/replace within some template boundary
     */
    private static void generateContent(final List<String> source, final Writer writer, final String className) throws IOException {
        final List<String> section = new ArrayList<>();
        String[] outputTypes = null;
        String inputType = null;
        for (String line : source) {
            if (line.contains(className + PROTO_UTILCLASS_SUFFIX)) {
                line = line.replace(className + PROTO_UTILCLASS_SUFFIX, className);
            }
            if (line.trim().startsWith(START_TEMPLATE)) {
                final String[] tokens = line.trim().substring(START_TEMPLATE.length()).split("->");
                inputType = tokens[0].trim();
                outputTypes = Arrays.stream(tokens[1].split(",")).map(s -> s.trim()).toArray(String[] ::new);
            } else if (line.trim().startsWith(END_TEMPLATE)) {
                if (outputTypes == null) {
                    section.clear();
                } else {
                    final String indentation = "    "; // TODO: get correct indentation for section
                    // output all collected lines for all types:
                    for (final String outputType : outputTypes) {
                        writeTypeSection(writer, section, inputType, indentation, outputType);
                    }
                    // reset
                    section.clear();
                    inputType = null;
                    outputTypes = null;
                }
            } else if (inputType != null && outputTypes != null) {
                section.add(line);
            }
            writer.write(line);
            writer.write("\n");
        }
    }

    private static void writeTypeSection(final Writer writer, final List<String> section, final String inputType, final String indentation, final String outputType) throws IOException {
        // write section header comment for type
        writer.write(indentation);
        writer.write("// start: ");
        writer.write(outputType);
        writer.write("\n");
        // rewrite section for current type
        final Map<String, String> substitutions = new HashMap<>();
        for (final String currentLine : section) {
            boolean skip = false;
            boolean returncast = false;
            substitutions.clear();
            // check for line modifiers //// codegen: <command> ....
            final int cmdIndex = currentLine.indexOf(LINE_COMMAND);
            if (cmdIndex >= 0) {
                String[] commands = Arrays.stream(currentLine.substring(cmdIndex + LINE_COMMAND.length() + 1).split("////")).map(String::trim).toArray(i -> new String[i]);
                for (final String command : commands) {
                    if (command.startsWith(COMMAND_SKIP)) {
                        skip = command.substring(COMMAND_SKIP.length()).contains(outputType);
                        skip = skip || command.substring(COMMAND_SKIP.length()).contains("all");
                    } else if (command.startsWith(COMMAND_CAST_RETURN)) {
                        returncast = command.substring(COMMAND_CAST_RETURN.length()).contains(outputType);
                        returncast = returncast || command.substring(COMMAND_CAST_RETURN.length()).contains("all");
                    } else if (command.startsWith(COMMAND_SUBST)) {
                        final String[] tokens = command.split(String.valueOf(command.charAt(COMMAND_SUBST.length())));
                        if (tokens[1].contains(outputType) || tokens[1].contains("all")) {
                            substitutions.put(tokens[2], tokens[3]);
                        }
                    }
                }
            }
            // apply substitutions and commands
            if (skip) {
                writer.write(currentLine);
                writer.write("\n");
                continue;
            }
            String result = currentLine.replace(inputType, outputType).replace(capitalise(inputType), capitalise(outputType));
            if (returncast) {
                result = result.replace(" = ", " = (" + outputType + ") ")
                                 .replace("return ", "return (" + outputType + ") ");
            }
            for (final Map.Entry<String, String> substitution : substitutions.entrySet()) {
                result = result.replace(substitution.getKey(), substitution.getValue());
            }
            writer.write(result);
            writer.write("\n");
        }
        // write section footer comment for type
        writer.write(indentation);
        writer.write("// end: ");
        writer.write(outputType);
        writer.write("\n\n");
    }

    private static String capitalise(final String input) {
        if (input == null) {
            return null;
        }
        if (input.length() == 0) {
            return "";
        }
        return Character.toUpperCase(input.charAt(0)) + input.substring(1);
    }

    private static void writeLines(List<String> lines, Writer writer, UnaryOperator<String> converter) throws IOException {
        for (String line : lines) {
            writer.write(converter.apply(line));
            writer.write("\n");
        }
    }

    private static String removeTail(String string, String tail) {
        if (!string.endsWith(tail))
            throw new IllegalStateException(string + " does not end with " + tail);
        return string.substring(0, string.length() - tail.length());
    }
}
