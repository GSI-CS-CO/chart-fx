package de.gsi.generate;

import static java.nio.file.StandardOpenOption.*;

import java.io.IOException;
import java.io.Writer;
import java.nio.file.*;
import java.util.List;
import java.util.function.UnaryOperator;
import java.util.stream.Collectors;

import org.apache.maven.plugin.AbstractMojo;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugins.annotations.LifecyclePhase;
import org.apache.maven.plugins.annotations.Mojo;
import org.apache.maven.plugins.annotations.Parameter;
import org.apache.maven.project.MavenProject;

/**
 * Proof of concept code generator that gets called by the maven exec plugin during the generate
 * sources phase. It checks the source files for code gen templates by assuming some naming convention,
 * and then does search/replace based on sections within the source file. This allows multiple
 * output types to be generated into a single class.
 *
 * Currently the generated class inherits from the base class, but I'm not sure that's necessary.
 * We could just generate a full copy of the base class and then add sections within the template
 * area. TBD.
 *
 * @author ennerf
 * @author Alexander Krimm
 */
@Mojo(name = "generate-sources", defaultPhase = LifecyclePhase.GENERATE_SOURCES)
public class CodeGenerator extends AbstractMojo {
    public static final String PROTOTYPE_TYPE = "double";
    public static final String PROTOTYPE_CLASS_SUFFIX = "DoubleProto";
    public static final String JAVA_FILE_SUFFIX = ".java";
    public static final String PROTOTYPE_TYPE_BOXED = "Double";
    public static final String AUTOGENERATED_WARNING_HEADER = "// This file has been generated automatically. Do not modify!\n";
    final String[] outputTypes = { "float", "char", "short", "int", "long", "boolean", "byte" };

    @Parameter(defaultValue = "${project}", required = true, readonly = true)
    MavenProject project;

    @Parameter(defaultValue = "${project.build.sourceDirectory}", readonly = true)
    String input;
    @Parameter(defaultValue = "${project.build.directory}/generated-sources/codegen", readonly = true)
    String output;

    @Override
    public void execute() throws MojoExecutionException {
        final Path inputPath = Path.of(this.input);
        final Path outputPath = Path.of(this.output);

        project.addCompileSourceRoot(this.output); // Add the generated classes to the build path
        if (getLog().isInfoEnabled()) {
            getLog().info("Added directory for generated sources to compile sources: " + outputPath);
        }

        // Adding other types to helper function classes (...GenBase.java)
        extendUtilityClass(inputPath, outputPath);

        // Adding new classes for different types (...DoubleProto.");java)
        addDataTypeVariants(inputPath, outputPath);
    }

    private void addDataTypeVariants(final Path inputPath, final Path outputPath) throws MojoExecutionException {
        final PathMatcher matcherTypes = FileSystems.getDefault().getPathMatcher("glob:**" + PROTOTYPE_CLASS_SUFFIX + JAVA_FILE_SUFFIX);
        final List<Path> sourcesTypes;
        try {
            sourcesTypes = Files.walk(inputPath).filter(matcherTypes::matches).collect(Collectors.toList());
        } catch (IOException e) {
            throw new MojoExecutionException("Error reading File", e);
        }

        for (final Path source : sourcesTypes) {
            // Create output package
            Path relativePath = inputPath.relativize(source);
            Path outputDirectory = outputPath.resolve(relativePath.getParent());
            try {
                Files.createDirectories(outputDirectory);
            } catch (IOException e) {
                throw new MojoExecutionException("Error reading File", e);
            }

            // Find base class to be generated
            final String sourceClassName = removeTail(source.getFileName().toString(), JAVA_FILE_SUFFIX);
            final String outputClassNameBase = removeTail(sourceClassName, PROTOTYPE_CLASS_SUFFIX);
            final List<String> sourceContent;
            try {
                sourceContent = Files.readAllLines(source);
            } catch (IOException e) {
                throw new MojoExecutionException("Error reading File", e);
            }

            // Generate output file
            // primitive types
            for (final String outputType : outputTypes) {
                final String outputClassSuffix = outputType.substring(0, 1).toUpperCase() + outputType.substring(1);
                final String outputClassName = outputClassNameBase + outputClassSuffix;
                final Path dest = outputDirectory.resolve(outputClassName + JAVA_FILE_SUFFIX);
                try (Writer writer = Files.newBufferedWriter(dest, CREATE, WRITE, TRUNCATE_EXISTING)) {
                    // Write minimum class layout. Maybe use JavaPoet?
                    writer.write(AUTOGENERATED_WARNING_HEADER);
                    writer.write("// autogenerated code for " + outputType + " - " + outputType + " from double\n");
                    writeLines(sourceContent, writer, line -> {
                        // add a "// noconvert" comment to a line to suppress replacing double by the current type
                        if (line.contains("// noconvert")) {
                            return line;
                        }
                        return line.replace(PROTOTYPE_TYPE, outputType).replace(PROTOTYPE_CLASS_SUFFIX, outputClassSuffix);
                    });
                } catch (IOException e) {
                    throw new MojoExecutionException("Error reading File", e);
                }
            }
            // generic type
            final String outputClassSuffix = "Object";
            final String outputClassName = outputClassNameBase + outputClassSuffix;
            final Path dest = outputDirectory.resolve(outputClassName + JAVA_FILE_SUFFIX);
            try (Writer writer = Files.newBufferedWriter(dest, CREATE, WRITE, TRUNCATE_EXISTING)) {
                // Write minimum class layout. Maybe use JavaPoet?
                writer.write(AUTOGENERATED_WARNING_HEADER);
                writer.write("// autogenerated code for Object<T> from double\n");
                writeLines(sourceContent, writer, line -> {
                    // add a "// noconvert" comment to a line to suppress replacing double by the current type
                    if (line.contains("// noconvert")) {
                        return line;
                    }
                    String result = line.replace(PROTOTYPE_CLASS_SUFFIX, line.contains("class") ? "Object<T>" : "Object")
                                            .replace(PROTOTYPE_TYPE, "T");
                    if (line.contains("allocate(")) {
                        result = result.replace(") {", ", final Class<T[]> clazz) {");
                    }
                    if (result.contains("new T")) {
                        getLog().info("replacing new T" + line);
                        result = "try { " + result.replaceAll("new T\\[(.*)]", "clazz.getConstructor(int.class).newInstance($1)")
                                 + " } catch (InstantiationException | NoSuchMethodException | IllegalAccessException | java.lang.reflect.InvocationTargetException e) { throw new IllegalArgumentException(\"Could not allocate array for given type\", e);}";
                    }
                    if (line.contains("static ") && !line.contains("static class")) { // add type parameter to static methods
                        return result.replace("static", "static <T>");
                    }
                    return result;
                });
            } catch (IOException e) {
                throw new MojoExecutionException("Error reading File", e);
            }
        }
    }

    private void extendUtilityClass(final Path inputPath, final Path outputPath) throws MojoExecutionException {
        final PathMatcher matcher = FileSystems.getDefault().getPathMatcher("glob:**GenBase.java");
        final List<Path> sources;
        try {
            sources = Files.walk(inputPath).filter(matcher::matches).collect(Collectors.toList());
        } catch (IOException e) {
            throw new MojoExecutionException("could not enumerate files", e);
        }

        for (final Path source : sources) {
            // Create output package
            Path relativePath = inputPath.relativize(source);
            Path outputDirectory = outputPath.resolve(relativePath.getParent());
            try {
                Files.createDirectories(outputDirectory);
            } catch (IOException e) {
                throw new MojoExecutionException("could not create directories", e);
            }

            // Find name to be generated
            String sourceClassName = removeTail(source.getFileName().toString(), JAVA_FILE_SUFFIX);
            String outputClassName = removeTail(sourceClassName, "GenBase");

            // Generate output file
            Path dest = outputDirectory.resolve(outputClassName + JAVA_FILE_SUFFIX);
            final List<String> sourceContent;
            try {
                sourceContent = Files.readAllLines(source);
            } catch (IOException e) {
                throw new MojoExecutionException("Error reading File", e);
            }
            try (Writer writer = Files.newBufferedWriter(dest, CREATE, WRITE, TRUNCATE_EXISTING)) {
                // Write minimum class layout. Maybe use JavaPoet?
                writer.write(AUTOGENERATED_WARNING_HEADER);
                writer.write("package " + relativePath.getParent().toString().replaceAll("(\\\\|/)", ".") + ";\n");
                generateImports(sourceContent, writer);
                writer.write(String.format("public class %s extends %s {%n", outputClassName, sourceClassName));
                generateContent(sourceContent, writer);
                writer.write("\n}");
            } catch (IOException e) {
                throw new MojoExecutionException("Error reading File", e);
            }
        }
    }

    private static void generateImports(List<String> source, Writer writer) throws IOException {
        List<String> lines = getSection(source,
                "//// === BEGIN IMPORTS ===",
                "//// === END IMPORTS ===");
        writeLines(lines, writer, line -> line);
    }

    /**
     * Generate some sort of code, e.g., search/replace within some template boundary
     */
    private static void generateContent(List<String> source, Writer writer) throws IOException {
        // Limit file contents to the "template" section within the source file
        List<String> lines = getSection(source,
                "//// === BEGIN TEMPLATE ===",
                "//// === END TEMPLATE ===");

        writer.write("// <float>");
        writeLines(lines, writer, line -> line.replace(PROTOTYPE_TYPE, "float").replace(PROTOTYPE_TYPE_BOXED, "Float"));

        writer.write("// <short>");
        writeLines(lines, writer, line -> line.replace(PROTOTYPE_TYPE, "short").replace(PROTOTYPE_TYPE_BOXED, "Short"));

        writer.write("// <int>");
        writeLines(lines, writer, line -> line.replace(PROTOTYPE_TYPE, "int").replace(PROTOTYPE_TYPE_BOXED, "Int"));

        writer.write("// <long>");
        writeLines(lines, writer, line -> line.replace(PROTOTYPE_TYPE, "long").replace(PROTOTYPE_TYPE_BOXED, "Long"));
    }

    private static void writeLines(List<String> lines, Writer writer, UnaryOperator<String> converter) throws IOException {
        for (String line : lines) {
            writer.write(converter.apply(line));
            writer.write("\n");
        }
    }

    private static List<String> getSection(List<String> source, String beginIdentifier, String endIdentifier) throws IOException {
        int startIndex = source.indexOf(beginIdentifier);
        int endIndex = source.lastIndexOf(endIdentifier);
        if (startIndex < 0) {
            throw new IOException("File does not contain identifier: " + beginIdentifier);
        } else if (endIndex < 0) {
            throw new IOException("File does not contain identifier: " + endIdentifier);
        } else {
            return source.subList(startIndex + 1, endIndex);
        }
    }

    private static String removeTail(String string, String tail) {
        if (!string.endsWith(tail))
            throw new IllegalStateException(string + " does not end with " + tail);
        return string.substring(0, string.length() - tail.length());
    }
}
